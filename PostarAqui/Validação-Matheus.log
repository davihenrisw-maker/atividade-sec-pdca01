Nome: DAVI HENRIQUE SALES
Atividade01 - Seguran√ßa
Dia: 26/08/2025

# atividade-sec-pdca01
Atividade Aula Seguran√ßa 01 - Faculdade Serra Dourada Lorena

C√≥digo a ser analisado em python!

<pre>
usuarios = {
    "admin": "123456",  
    "joao": "senha",
    "maria": "1234"
}

def login(usuario, senha):
    if usuario in usuarios and usuarios[usuario] == senha:
        return f"Bem-vindo, {usuario}!"
    else:
        return "Usu√°rio ou senha inv√°lidos."

if __name__ == "__main__":
    print("=== Sistema de Login ===")
    user = input("Usu√°rio: ")
    pwd = input("Senha: ")
    print(login(user, pwd))
</pre>


# O que tem que ser feito
Aplica√ß√£o do PDCA

üîπ Plan (Planejar)
Identificar vulnerabilidades no c√≥digo acima.
Analisar riscos (Probabilidade x Impacto) de explora√ß√£o.
Vulnerabilidades

Senhas armazenadas em texto puro (hardcoded)

O dicion√°rio usuarios guarda as senhas em texto simples dentro do c√≥digo.

Isso √© perigoso porque:

Se algu√©m acessar o c√≥digo, ter√° acesso direto √†s senhas.

N√£o h√° nenhuma forma de prote√ß√£o (hash, criptografia).

Usu√°rios e senhas fixos dentro do c√≥digo

Boa pr√°tica: armazenar em banco de dados, arquivo seguro ou usar vari√°veis de ambiente.

Nenhuma prote√ß√£o contra ataques de for√ßa bruta

O programa permite tentar infinitas vezes at√© acertar usu√°rio/senha.

Um invasor pode automatizar tentativas.

Boa pr√°tica: limitar tentativas, implementar bloqueio tempor√°rio

O c√≥digo retorna sempre "Usu√°rio ou senha inv√°lidos".

Aqui n√£o h√° inje√ß√£o SQL porque voc√™ n√£o usa banco de dados

Aus√™ncia de auditoria ou log

N√£o h√° registro de quem tentou logar, nem das falhas.


# Tabela de Riscos

| ID | Risco                          | Probabilidade | Impacto  |
|----|--------------------------------|---------------|----------|
| 01 | Falha no servidor              | Alta          | Alto     | 
| 02 | Erro humano em opera√ß√£o        | M√©dia         | M√©dio    |
| 03 | Atraso de fornecedor           | Alta          | M√©dio    |
| 04 | Vazamento de dados             | Alto         | Alto     |
| 05 | Ataque cibern√©tico             | M√©dia         | Alto     |


üîπ Do (Executar)
Corrigir c√≥digo (citar quais s√£o as corre√ß√µes feitas)

import hashlib

# Fun√ß√£o para gerar hash da senha
def gerar_hash(senha):
    return hashlib.sha256(senha.encode()).hexdigest()

# Usu√°rios com senhas j√° em hash (n√£o em texto puro)
usuarios = {
    "admin": gerar_hash("123456"),
    "joao": gerar_hash("senha"),
    "maria": gerar_hash("1234")
}

def login(usuario, senha):
    senha_hash = gerar_hash(senha)
    if usuario in usuarios and usuarios[usuario] == senha_hash:
        return f"‚úÖ Bem-vindo, {usuario}!"
    else:
        return "‚ùå Usu√°rio ou senha inv√°lidos."

if __name__ == "__main__":
    print("=== Sistema de Login Seguro ===")
    tentativas = 0
    while tentativas < 3:  # Limite de 3 tentativas
        user = input("Usu√°rio: ")
        pwd = input("Senha: ")
        resultado = login(user, pwd)
        print(resultado)
        if "Bem-vindo" in resultado:
            break
        tentativas += 1
    if tentativas == 3:
        print("üö® Muitas tentativas falhas. Acesso bloqueado.")

Diferen√ßas principais:

As senhas n√£o ficam em texto puro ‚Üí s√£o convertidas em hash SHA-256.

Adicionado limite de 3 tentativas ‚Üí evita for√ßa bruta.

Mantido bem simples para rodar direto no VS Code.

## Subir vers√£o corrigida para o GitHub respondendo abaixo os itens:

Question√°rio para os alunos

Quais vulnerabilidades voc√™ encontrou no c√≥digo original?

Senhas armazenadas em texto puro.

Usu√°rios e senhas fixos no c√≥digo (hardcoded).

Sem hash ou criptografia.

Sem limite de tentativas (permite for√ßa bruta).

Mensagem de erro pode ajudar em ataques (confirma exist√™ncia de usu√°rio).

Sem logs ou auditoria de tentativas.

Qual vulnerabilidade apresentou maior risco (P x I)?
# Tabela de Riscos ‚Äì Sistema de Login

| Risco                        | Probabilidade (P) | Impacto (I) | N√≠vel (P x I) | Mitiga√ß√£o |
|-------------------------------|-----------------|------------|---------------|-----------|
| Senhas expostas em texto puro | M√©dia           | Alto       | Alto          | Usar hash seguro (SHA-256, bcrypt) |
| For√ßa bruta / m√∫ltiplas tentativas | Alta        | M√©dio      | Alto         | Limitar tentativas, bloqueio tempor√°rio |
| Erro humano na cria√ß√£o de contas | M√©dia        | M√©dio      | Moderado      | Valida√ß√£o de dados, auditoria |
| Vazamento de dados do c√≥digo  | Baixa           | Alto       | Moderado      | Armazenar senhas fora do c√≥digo (BD seguro ou vari√°veis de ambiente) |
| Mensagem de erro informativa  | M√©dia           | Baixo      | Baixo         | Usar mensagens gen√©ricas para usu√°rio final |


Qual seria o impacto real se essa falha fosse explorada em uma empresa?

Invas√£o de dados da empresa, comprometendo a garantia das informa√ß√µes.

Como voc√™ corrige as falhas encontradas?

Criando um sistema de hash e limitando as tentativas de acesso.

Ap√≥s aplicar o PDCA, quais melhorias foram efetivas?
respondidas na pergunta acima.

## Voc√™s Alunos dever√£o fazer:
Fork: O aluno faz um "fork" do seu reposit√≥rio. Isso cria uma c√≥pia completa do seu projeto na conta dele. O reposit√≥rio original √© chamado de "upstream" e a c√≥pia do aluno √© o "origin".

Clone e Trabalho: O aluno clona a c√≥pia dele (o "origin") para a m√°quina local e faz as altera√ß√µes no c√≥digo.

Commit e Push: Ap√≥s as altera√ß√µes, o aluno faz um "commit" e envia (push) as mudan√ßas para o reposit√≥rio dele no GitHub.

Pull Request: O aluno abre um Pull Request do reposit√≥rio dele (o "origin") para o seu reposit√≥rio original (o "upstream").